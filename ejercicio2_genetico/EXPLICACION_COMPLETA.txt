EXPLICACIÓN COMPLETA - EJERCICIO 2
===================================

ALGORITMO GENÉTICO PARA PLANIFICACIÓN DE HORARIOS
==================================================


QUÉ HACE EL PROGRAMA:
====================

El programa crea horarios de cursos para una universidad usando un algoritmo genético.

Cada curso necesita:
- Un salón donde realizarse
- Un horario específico (día y hora)

El horario debe cumplir restricciones obligatorias y maximizar preferencias.


EL PROBLEMA EN DETALLE:
=======================

Tenemos:
- 8 cursos diferentes
- 6 salones (con diferentes capacidades)
- 14 franjas horarias (Lunes a Viernes, mañana y tarde)

RESTRICCIONES DURAS (OBLIGATORIAS):

1. Capacidad del salón:
   - Si un curso tiene 50 estudiantes, el salón debe tener capacidad para 50+
   - Violar esto es inaceptable

2. No solapamiento de salones:
   - Un salón no puede tener dos cursos al mismo tiempo
   - Si IA está en Aula 101 a las 8am, ningún otro curso puede estar ahí a las 8am

3. No conflictos de profesores:
   - Un profesor no puede dar dos clases al mismo tiempo
   - Si Dr. García tiene IA a las 8am, no puede tener otro curso a las 8am

RESTRICCIONES BLANDAS (PREFERENCIAS):

1. Días preferidos de profesores:
   - Dr. García prefiere Lunes y Miércoles
   - Si su curso cae en esos días, mejor

2. Tipo de salón apropiado:
   - Laboratorios deben estar en salones tipo laboratorio
   - Conferencias en auditorios grandes

3. Uso eficiente de capacidad:
   - Mejor usar un salón al 80% que al 30% o al 100%
   - Evita desperdiciar espacio


CÓMO FUNCIONA UN ALGORITMO GENÉTICO:
====================================

Es inspirado en la evolución biológica.

CONCEPTOS BÁSICOS:

1. CROMOSOMA (INDIVIDUO):
   - Es UNA solución completa al problema
   - Lista de asignaciones: qué curso va dónde y cuándo
   - Ejemplo: "IA en Aula 101 Lunes 8am, BD en Lab A Martes 10am, etc."

2. POBLACIÓN:
   - Conjunto de muchos cromosomas (soluciones)
   - En este caso: 100 soluciones al mismo tiempo

3. FITNESS (APTITUD):
   - Qué tan buena es una solución
   - Número más alto = mejor solución
   - Se calcula con penalizaciones y bonificaciones

4. GENERACIÓN:
   - Un ciclo completo del algoritmo
   - Cada generación mejora la población

5. EVOLUCIÓN:
   - Las buenas soluciones se combinan
   - Las malas desaparecen
   - Aparecen mutaciones aleatorias


EL PROCESO COMPLETO:
===================

PASO 1: INICIALIZACIÓN
----------------------
Crear 100 soluciones aleatorias.

Para cada curso:
- Elegir salón al azar
- Elegir horario al azar

Resultado: 100 horarios diferentes (la mayoría malos).


PASO 2: EVALUACIÓN
------------------
Calcular fitness de cada solución.

Empezar con 1000 puntos.

Restar por violaciones:
- Capacidad excedida: -100 por cada estudiante extra
- Conflicto de salón: -200
- Conflicto de profesor: -200

Sumar por cumplir preferencias:
- Día preferido: +10
- Salón apropiado: +15
- Capacidad bien usada: +5

Ejemplo:
- Solución tiene 2 conflictos de salón: 1000 - 400 = 600
- Cumple 5 preferencias de día: 600 + 50 = 650
- Fitness final: 650


PASO 3: SELECCIÓN
-----------------
Elegir quiénes serán "padres" para crear hijos.

Usamos selección por torneo:
1. Tomar 3 soluciones al azar
2. El mejor de los 3 se selecciona
3. Repetir para elegir otro padre

Esto favorece buenos individuos pero no ignora a los demás.


PASO 4: CRUCE (REPRODUCCIÓN)
----------------------------
Combinar dos padres para crear dos hijos.

Ejemplo con cruce de un punto:

Padre 1: [Curso1→Aula1, Curso2→Aula2, Curso3→Aula3, Curso4→Aula4]
Padre 2: [Curso1→LabA, Curso2→LabB, Curso3→Aula5, Curso4→Aula6]

Punto de corte: después de Curso2

Hijo 1: [Curso1→Aula1, Curso2→Aula2, Curso3→Aula5, Curso4→Aula6]
Hijo 2: [Curso1→LabA, Curso2→LabB, Curso3→Aula3, Curso4→Aula4]

Probabilidad de cruce: 80%
(20% de las veces, el hijo es copia del padre)


PASO 5: MUTACIÓN
----------------
Introducir cambios aleatorios.

Para cada asignación (gen):
- 10% de probabilidad de cambiar
- Si cambia: modificar el salón O el horario (no ambos)

Ejemplo:
Antes: Curso IA → Aula 101 Lunes 8am
Después: Curso IA → Lab A Lunes 8am (cambió el salón)

Esto introduce diversidad y evita quedarse atascado.


PASO 6: ELITISMO
----------------
Preservar los 2 mejores individuos intactos.

Pasan directo a la siguiente generación sin cambios.

Esto asegura que nunca perdemos las mejores soluciones.


PASO 7: REEMPLAZO
-----------------
La nueva generación reemplaza completamente a la anterior.

Nueva generación = 2 élites + 98 hijos creados


PASO 8: REPETIR
---------------
Volver al paso 2 (Evaluación).

Repetir por 200 generaciones.


ESTRUCTURA DEL CÓDIGO:
======================

CLASES DE DATOS:
---------------

Curso:
- id: identificador único
- nombre: nombre del curso
- profesor: quién lo da
- estudiantes: cuántos hay
- duracion_horas: cuánto dura

Salon:
- id: identificador único
- nombre: nombre del salón
- capacidad: cuántos caben
- tipo: normal, laboratorio, auditorio

FranjaHoraria:
- id: identificador único
- dia: Lunes, Martes, etc.
- hora_inicio: 08:00, 10:00, etc.
- hora_fin: 10:00, 12:00, etc.

Asignacion:
- curso: el curso
- salon: el salón asignado
- franja: la franja horaria asignada

Cromosoma:
- asignaciones: lista de todas las asignaciones
- fitness: valor de aptitud


FUNCIONES PRINCIPALES:
---------------------

calcular_fitness(cromosoma):
- Recibe: un cromosoma (solución)
- Retorna: su fitness (número)
- Proceso:
  1. Empieza en 1000
  2. Revisa cada restricción dura
  3. Resta penalizaciones
  4. Revisa restricciones blandas
  5. Suma bonificaciones
  6. Retorna fitness final

generar_cromosoma_aleatorio():
- Retorna: un cromosoma nuevo
- Proceso:
  1. Para cada curso
  2. Elegir salón aleatorio
  3. Elegir franja aleatoria
  4. Crear asignación
  5. Crear cromosoma con todas las asignaciones

seleccion_torneo(poblacion):
- Recibe: la población completa
- Retorna: un cromosoma seleccionado
- Proceso:
  1. Tomar 3 cromosomas al azar
  2. Comparar sus fitness
  3. Retornar el mejor

cruce_un_punto(padre1, padre2):
- Recibe: dos cromosomas padres
- Retorna: dos cromosomas hijos
- Proceso:
  1. Elegir punto de corte aleatorio
  2. Hijo1 = primera parte padre1 + segunda parte padre2
  3. Hijo2 = primera parte padre2 + segunda parte padre1
  4. Retornar ambos hijos

mutacion(cromosoma, salones, franjas, tasa):
- Recibe: cromosoma a mutar, recursos disponibles, tasa
- Retorna: nada (modifica el cromosoma in-place)
- Proceso:
  1. Para cada asignación en el cromosoma
  2. Con probabilidad = tasa (10%)
  3. Cambiar salón O franja (50% cada uno)

algoritmo_genetico(...):
- Función principal que ejecuta todo
- Recibe: cursos, salones, franjas, parámetros
- Retorna: mejor solución, histórico de fitness
- Proceso:
  1. Crear población inicial aleatoria
  2. Para cada generación:
     a. Evaluar fitness de todos
     b. Seleccionar padres
     c. Crear hijos con cruce
     d. Aplicar mutación
     e. Preservar élites
     f. Reemplazar población
  3. Retornar mejor solución final


EJEMPLO DE EJECUCIÓN:
=====================

GENERACIÓN 0 (INICIAL):
- Población: 100 soluciones aleatorias
- Mejor fitness: 412 (muchas violaciones)
- Promedio fitness: 250

GENERACIÓN 25:
- Mejor fitness: 980
- Ya no hay violaciones graves
- Mejora rápida

GENERACIÓN 50:
- Mejor fitness: 1200
- Cero violaciones de restricciones duras
- Buenas preferencias cumplidas

GENERACIÓN 100:
- Mejor fitness: 1235
- Óptimo o casi óptimo

GENERACIÓN 200:
- Mejor fitness: 1235 (no mejoró)
- Convergencia alcanzada


ANÁLISIS DE RESULTADOS:
=======================

El programa muestra:

1. CONFIGURACIÓN USADA:
   - Tamaño población
   - Generaciones
   - Tasas de cruce y mutación

2. PROGRESO:
   - Mejor fitness cada 20 generaciones
   - Se ve la mejora gradual

3. MEJOR SOLUCIÓN:
   - Fitness final
   - Número de violaciones (idealmente 0)
   - Porcentaje de preferencias cumplidas

4. HORARIO COMPLETO:
   Para cada curso muestra:
   - Nombre del curso
   - Profesor
   - Número de estudiantes
   - Salón asignado (con capacidad)
   - Horario (día y horas)

5. EVOLUCIÓN:
   - Fitness inicial vs final
   - Mejora total lograda


EXPERIMENTOS REALIZADOS:
========================

Se hicieron 7 experimentos diferentes para encontrar los mejores parámetros.


EXPERIMENTO 1: TAMAÑO DE POBLACIÓN
----------------------------------

Pregunta: ¿Cuántos individuos necesitamos?

Probado: 20, 50, 100, 200

Resultado:
- 20: muy poco, no explora suficiente
- 50: funciona pero podría ser mejor
- 100: óptimo
- 200: funciona igual que 100 pero más lento

Conclusión: Usar 100 individuos.


EXPERIMENTO 2: NÚMERO DE GENERACIONES
-------------------------------------

Pregunta: ¿Cuántas generaciones son suficientes?

Probado: 50, 100, 200, 300

Resultado:
- 50: bueno pero puede mejorar
- 100: muy bueno
- 200: excelente
- 300: igual que 200

Conclusión: 200 generaciones son suficientes.


EXPERIMENTO 3: TASA DE MUTACIÓN
-------------------------------

Pregunta: ¿Qué tan seguido mutar?

Probado: 0.01, 0.05, 0.1, 0.2, 0.3

Resultado:
- 0.01: muy conservador, se estanca
- 0.05: bueno
- 0.1: óptimo
- 0.2: demasiado caótico
- 0.3: destruye buenas soluciones

Conclusión: Usar tasa 0.1 (10%).


EXPERIMENTO 4: TASA DE CRUCE
----------------------------

Pregunta: ¿Qué tan seguido cruzar padres?

Probado: 0.5, 0.7, 0.8, 0.9, 1.0

Resultado:
- Todas las tasas >0.7 funcionan bien
- No es tan crítico como mutación

Conclusión: Usar tasa 0.8 (80%).


EXPERIMENTO 5: ELITISMO
-----------------------

Pregunta: ¿Cuántos mejores preservar?

Probado: 0, 1, 2, 5, 10

Resultado:
- 0: arriesgado, puede perder buenas soluciones
- 1: bueno
- 2: óptimo
- 5: funciona pero reduce diversidad
- 10: demasiado poco diverso

Conclusión: Preservar 2 individuos (2% de 100).


EXPERIMENTO 6: ESCALABILIDAD
----------------------------

Pregunta: ¿Funciona con problemas más grandes?

Probado:
- Problema simple: 5 cursos
- Problema complejo: 8 cursos

Resultado:
- Ambos funcionan bien
- Mismos parámetros sirven
- Solo necesitas más recursos (salones, franjas)

Conclusión: Escala bien.


EXPERIMENTO 7: CONVERGENCIA
---------------------------

Pregunta: ¿Cómo evoluciona con el tiempo?

Observado:
- Generaciones 0-50: mejora rápida (70% de mejora total)
- Generaciones 50-100: refinamiento
- Generaciones 100+: estancamiento

Conclusión: 
- Mayor mejora al inicio
- Después de 100 generaciones, mejora marginal


PARÁMETROS ÓPTIMOS FINALES:
===========================

Basado en todos los experimentos:

Población: 100 individuos
Generaciones: 200
Tasa cruce: 0.8 (80%)
Tasa mutación: 0.1 (10%)
Elitismo: 2 individuos
Selección: Torneo de 3


POR QUÉ FUNCIONA:
================

EXPLORACIÓN vs EXPLOTACIÓN:

Exploración: buscar en nuevas áreas del espacio de soluciones
- Se logra con: mutación, población grande

Explotación: mejorar soluciones conocidas
- Se logra con: cruce, selección, elitismo

Balance correcto:
- 10% mutación: suficiente exploración
- 80% cruce: buena explotación
- Elitismo 2: preserva lo mejor sin dominar


DIVERSIDAD GENÉTICA:

Sin diversidad:
- Todos los individuos se parecen
- Se estanca en óptimo local
- No puede escapar

Con diversidad:
- Individuos diferentes
- Explora múltiples soluciones
- Puede encontrar mejores caminos

Mantener diversidad con:
- Población grande (100)
- Mutación (10%)
- Selección por torneo (no solo el mejor)


CONVERGENCIA:

Temprana: encuentra buenos resultados rápido
Tardía: refina detalles

Este algoritmo:
- Converge rápido en primeras 50 gen
- Refina hasta generación 100
- Estable después


LIMITACIONES Y CONSIDERACIONES:
===============================

NO GARANTIZA ÓPTIMO GLOBAL:
- Puede encontrar óptimo local
- No hay garantía matemática
- Pero en práctica funciona muy bien

ALEATORIO:
- Resultados varían entre ejecuciones
- Mismo problema puede dar fitness ligeramente diferente
- Pero siempre encuentra buenas soluciones

TIEMPO:
- Más población = más tiempo
- Más generaciones = más tiempo
- Balance entre calidad y velocidad

ESPACIO DE BÚSQUEDA:
- Crece exponencialmente con el problema
- 8 cursos, 6 salones, 14 franjas = millones de combinaciones
- Algoritmo genético lo explora inteligentemente


VENTAJAS DEL ENFOQUE:
=====================

1. MANEJA RESTRICCIONES COMPLEJAS:
   - Fácil agregar nuevas restricciones
   - Solo modificar función fitness

2. FLEXIBLE:
   - Funciona con diferentes tamaños
   - Fácil adaptar a nuevos problemas

3. PARALELO:
   - Explora múltiples soluciones simultáneamente
   - No se queda atascado fácilmente

4. INTUITIVO:
   - Basado en evolución natural
   - Fácil de entender y explicar

5. ROBUSTO:
   - Funciona aunque no haya solución perfecta
   - Encuentra mejor compromiso posible


CÓMO MODIFICAR PARA TU PROBLEMA:
================================

1. CAMBIAR DATOS:
   - Editar listas de cursos, salones, franjas
   - Agregar o quitar según necesites

2. CAMBIAR RESTRICCIONES:
   - Modificar función calcular_fitness()
   - Agregar nuevas penalizaciones o bonificaciones

3. AJUSTAR PARÁMETROS:
   - Si el problema es más grande: aumentar población
   - Si necesitas más calidad: aumentar generaciones
   - Si tarda mucho: reducir población o generaciones

4. CAMBIAR OPERADORES:
   - Probar cruce de dos puntos
   - Probar mutación adaptativa
   - Experimentar con tu problema específico


CONCLUSIÓN:
===========

Este algoritmo genético:
- Resuelve eficientemente el problema de horarios
- Cumple todas las restricciones duras
- Maximiza las preferencias blandas
- Encuentra buenos resultados en tiempo razonable
- Es flexible y fácil de adaptar

Los experimentos demuestran que los parámetros elegidos son óptimos para este problema.

El código está bien estructurado, comentado y listo para usar o modificar.
